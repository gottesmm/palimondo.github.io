<!DOCTYPE html>
<html>
  <head>
    <title>Sample distribution</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style> /* ct- prefixed rules come from Chartist.js */
      body {font-family: system-ui, -apple-system;}
      table {font-variant-numeric: tabular-nums;}
      .hovertext text {
        font-family: system-ui, -apple-system !important; font-size: .6rem !important; }
      .ct-major-tenth {display: block; position: relative; width: 100%}
      .ct-major-tenth:before {display: block; float: left; content: "";
          width: 0; height: 0; padding-bottom: 40%}
      .ct-major-tenth:after {display: table}
      .ct-major-tenth > svg {display: block;position: absolute; top: 0; left: 0}

      .ct-square {display: block; position: relative; width: 100%}
      .ct-square:before {display: block; float: left; content: "";
          width: 0; height: 0; padding-bottom: 100%}
      .ct-square:after {display: table}
      .ct-square > svg {display: block; position: absolute; top: 0; left: 0}
      .ct-major-tenth:after, .ct-square:after {content: "";clear: both}
      .ct-label, #note {font-size: .6rem; fill: rgba(0, 0, 0, .4); color: rgba(0, 0, 0, .4);}
      .ct-series {opacity: 0.5}
      .all-series {fill: Highlight; stroke: Highlight; opacity: 1}
      .selected, tr.selected {background-color: Highlight; color: HighlightText}
      .selected .sparkline {outline: auto; background-color: white;}
      .selected td:nth-child(n+11):nth-child(-n+16) {
        background: linear-gradient(to bottom, Highlight 0%, Highlight 10%,
          white 10%, white 90%, rgba(0,0,0,0) 90%, rgba(0,0,0,0) 100%)
      }
      .selected td:nth-child(n+13):nth-child(-n+13) { font-weight: bolder}
      tbody tr:hover {background-color: Highlight; }
      td {cursor: pointer;}
      .ct-point {stroke-width: 5px; stroke-linecap: round}
      h1 {font-size: 1.5rem}
      h2 {font-size: 1.1rem}

      .series h2 {float:left; margin-right: .5rem;}
      .series form {clear: none; color: black; font-size: 0.75rem; margin-top: 0.1rem;}
      #note {display: inline; margin-left: .8em;}

      table, table.raw, table.clean {caption-side: top !important;}
      caption {text-align: left}

      #stats {text-align: right;}
      .sparkline {/*background-color: #fafafa66;*/ width: 1rem; height: 1rem;}
      .sparkline .ct-point {stroke-width: 1px;}
      .raw .clean, .clean .raw {display: none}
      #sparkline {border: 1px solid red; display: none;}
      table { border-collapse:collapse; border-spacing:0;}
      td {padding: 0 .2rem}

      body > div, aside {display: flex}
      body {display: flex; flex-flow: column}
      body > div {flex: 3 3 100%; /*border: 1px solid pink */}

      #boxplot, #vertical-histogram {width: 10rem; flex: 0 0 6%}

      .navigation select { margin-top: 0; width: 2.9rem; height: 2.3rem; color: rgba(0, 0, 0, 0); background: red;}
      .navigation button {font-size: 150%; color: rgb(58, 153, 250); padding: 0.15em 0.7em; margin: 0; position: relative; }
      .navigation select, .navigation button { background: transparent; border: none; -webkit-appearance: none;}
      .navigation > button:last-of-type:after {content: '\25be'; padding: 0; margin: 0; position: absolute; left: 2.9em; top: 0; z-index: -1;}
      .navigation h1 {display: inline;}

      .hide {display: none !important; flex-basis: 0% !important}
      .hide.navigation {display: block !important}
      .hide > button, .hide > select { display: none !important }
      .hide.stats {display: table-row-group !important}
      .hide.stats tr:not(.selected) {display: none}

      h2 {margin-top: 0; font-size: 100%}

      #chart {flex: 1 1 50%}
      aside {flex: 1 1 50%}
      aside { display: flex; flex-flow: row wrap; order: 2;
        justify-content: space-between;}
      .series {flex: 1 1 auto; margin-bottom: .5em; display: flex; justify-content: space-around; /*border: 1px solid blue;*/}
      .series h2 { color: black; font-size: 1rem}
      .plots {flex: 1 30 auto; display: flex; flex-flow: row wrap; justify-content: space-around; /*border: 1px solid orange;*/}
      .histogram, .runtimes, .lagplot {flex: 1 1 33%; max-width: 14rem; min-width: 12rem;}
      .zoom {float: right}

      td > div.pair, th > div.pair {display: none}
      @media only screen and (max-width: 580px)  {
        td > div.pair, th > div.pair {display: block}
        td > div:not(.pair), th > div:not(.pair) {display: none}
        tr > td:first-of-type > div:not(.pair) {display: block} /* Runtimes exception*/
        td {padding: 0}
        td > div {padding: 0 0.2rem }
        .ct-major-tenth:before { padding-bottom: 80%}
        #boxplot, #vertical-histogram {width: 10rem; flex: 0 0 12%}
        .selected td:nth-child(n+11):nth-child(-n+16) {background: none}
        .selected td:nth-child(n+6):nth-child(-n+8) {
          background: linear-gradient(to bottom, Highlight 0%, Highlight 10%,
            white 10%, white 90%, rgba(0,0,0,0) 90%, rgba(0,0,0,0) 100%)
        }
        .selected td:nth-child(n+7):nth-child(-n+7) .pair div:first-child {
          font-weight: bolder}
      }

    </style>
    <meta name="viewport" content="initial-scale=1.0">
    <script>const $ = id => document.getElementById(id)</script>
  </head>
  <body>
    <form class="navigation">
      <div class="zoom">
        Zoom:
        <button id="autoscale" title="Autoscale" onclick="zoomAutoscale(); return false;">&nbsp;</button>
        <button id="resetzoom" title="Reset Zoom" onclick="resetZoom(); return false;">&nbsp;</button>
      </div>
      <button onclick="$('benchmark').selectedIndex--;">&#10094;</button>
      <button onclick="$('benchmark').selectedIndex++;">&#10095;</button>
      <select id="benchmark" name="f" onchange="document.forms[0].submit()"></select>
      <h1 id="title">Benchmark</h1>
    </form>
      <aside>
        <div class='series'>
          <table id="series" class="ct-label">
            <caption>
              <h2>Series</h2>
              <form class="ct-label">
                <input type="radio" name="series" id="raw" onchange="selectSeries(this)" checked>
                <label for="raw">Raw</label>
                <input type="radio" name="series" id="clean" onchange="selectSeries(this)">
                <label for="clean">Exclude Outliers</label>
                <p id='note'></p>
              </form>
            </caption>
            <thead>
              <tr id="titles"></tr>
            </thead>
            <tbody id="stats" class="stats">
            </tbody>
          </table>
          <!-- <div class="ct-chart ct-square sparkline" id="sparkline"></div> -->
        </div>
        <div class="plots">
	        <div class="histogram">
	          <h2>Histogram</h2>
	          <div class="ct-chart ct-square" id="histogram"></div>
	        </div>
	        <div class="runtimes">
	          <h2>Runtimes</h2>
	          <div class="ct-chart ct-square" id="runtimes"></div>
	        </div>
	        <div class="lagplot">
	          <h2>Lag plot</h2>
	          <div class="ct-chart ct-square" id="lag"></div>
	        </div>
	      </div>
      </div>
    </aside>
    <div class="main">
      <div id="boxplot"></div>
      <div class="ct-chart ct-major-tenth" id="chart"></div>
      <div id="vertical-histogram"></div>
    </div>
<script>

// Class manipulation helpers
function setClass(e, c) {
  let currentClasses = e.getAttribute('class')
  if (currentClasses && currentClasses.includes(c)) { return }
  e.setAttribute('class', currentClasses + ' ' + c)
}
function removeClass(e, c) {
  e.setAttribute('class', e.getAttribute('class').replace(RegExp('\s?'+c), ''))
}
const select = (e) => setClass(e, 'selected')
const deselect = (e) => removeClass(e, 'selected')
const classes = e => e.getAttribute('class')

// Series helpers
const seriesClassPrefix = 'series-'
const isSeries = c => c.startsWith(seriesClassPrefix)
const hasSeries = cs => cs.includes(seriesClassPrefix)
const getSeries = cs => cs.split(' ').find(isSeries)
const seriesIndex = sc => series.findIndex(s => s.seriesClass === sc)
function findSeries(e) {
  if (e === document) {return null}
  else {
    let cs = classes(e)
    return (cs && hasSeries(cs)) ? getSeries(cs) : findSeries(e.parentNode)
  }
}
const seriesIsRaw = _ => $('series').className.endsWith('raw')
const elapsedTime = s => s.rawStats.sum * s.num_iters
const roundRange = r => r > 500 ? round(r) : round(r, 1)

// Math helpers
const max = (a, b) => Math.max(a, b)
const min = (a, b) => Math.min(a, b)
const log2N = n => Math.max(1, Math.ceil(Math.log2(n)))

function round(x, precision = 0) {
  let factor = Math.pow(10, precision);
  return Math.round(x * factor) / factor;
}

// Prelude helpers
const zip = rows=>rows[0].map((_,c)=>rows.map(row=>row[c]))
const enumerate = a => zip([[...a.keys()], a])
const join = (d1, d2) => Object.assign(Object.assign({}, d1), d2)
const isEqual = (a1, a2) =>
  a1.length===a2.length && a1.every((v,i)=> v === a2[i])

// Sorting helpers
const descendingByIterationsAndName = (a, b) =>
  (b.num_iters - a.num_iters) * 100 - a.name.localeCompare(b.name)
const ascending = (a,b) => a - b
const descending = (a,b) => b - a

// Timing helpers
const wait = (ms=1) => new Promise(resolve => setTimeout(resolve, ms))

// Style helpers
const colors = [
  'rgb(215, 2, 6)', 'rgb(240, 91, 79)', 'rgb(244, 198, 62)',
  'rgb(209, 121, 5)', 'rgb(69, 61, 63)', 'rgb(89, 146, 43)',
  'rgb(5, 68, 211)', 'rgb(107, 3, 146)', 'rgb(240, 91, 79)',
  'rgb(221, 164, 88)', 'rgb(234, 207, 125)', 'rgb(134, 121, 125)',
  'rgb(178, 195, 38)', 'rgb(97, 136, 226)']
const highlightBlue = 'rgb(58, 153, 250)'
const colorForSeries = s => (s.seriesClass === 'all-series') ? highlightBlue :
  colors[seriesIndex(s.seriesClass)]
const rgba = (color, opacity) => `rgba${color.slice(3, -1)}, ${opacity})`
const rbgaForSeries = s =>
  rgba(colorForSeries(s), opacity(log2N(s.data.length)))
const fillColorForSeries = s =>rgba(colorForSeries(s), 0.3)
const strokeWidth2 = n => 0.0245398 * (n*n) - 0.772207 * n + 6.64742
const strokeWidth = n => (n > 14) ? 0.7 : round(strokeWidth2(n)*.5, 2)
const opacity3 = n =>
  0.0016453 * (n*n*n) - 0.0297611 * (n*n) + 0.0790482 * n + 0.841333
const opacity = n => (n > 10) ? 0.3 : round(opacity3(n), 2)
const seriesLineRule = (seriesClass, length)  =>
  `.${seriesClass} .ct-line {
    stroke-width: ${strokeWidth(log2N(length))}px;
    opacity: ${opacity(log2N(length))} }`
const seriesColorRule = (seriesClass, color) =>
  `.${seriesClass} .ct-line, .${seriesClass} .ct-point {stroke: ${color}}`
const rowColorRule = (seriesClass, color) =>
  `tr.${seriesClass} {background: linear-gradient(to bottom,
    ${rgba(color, 0)} 90%, ${rgba(color, 0.3)} 100%)}`

const systemFont = {family: 'system-ui, -apple-system', size: 10}
const labelFont = join(systemFont, {color: 'rgba(0, 0, 0, 0.4)'})

function generateSeriesCSS() {
  sheet = document.styleSheets[1]
  const insertSeriesColorRules = ([s, color]) => {
    sheet.insertRule(seriesColorRule(s.seriesClass, color), 0)
    sheet.insertRule(rowColorRule(s.seriesClass, color), 0)
  }
  zip([series, colors]).forEach(insertSeriesColorRules)
  insertSeriesColorRules([allSeries, highlightBlue])
  series.forEach(s => sheet.insertRule(
	  seriesLineRule(s.seriesClass, s.data.length), 0))
}

// Array slicing & dicing helpers
function bisect_right(a, x, lo=0, hi=a.length) {
	while (lo < hi) {
		mid = (lo + hi) >> 1
		if (x < a[mid]) { hi = mid }
    else { lo = mid + 1 }
	}
  return lo
}
const bisect = bisect_right
const firstNonNull = a => a.findIndex(x => x != null)
function lastNonNull(a) {
  for (var i = a.length - 1; i >= 0; i--) {
    if (a[i] != null) { return i } }
  return -1
}

// Icons
const svgNS = 'http://www.w3.org/2000/svg'
function createIcon(i) {
    let iconHeight = i.ascent - i.descent,
        icon = document.createElementNS(svgNS, 'svg'),
        path = document.createElementNS(svgNS, 'path');

    icon.setAttribute('style', 'fill: rgb(58, 153, 250); stroke: rgb(58, 153, 250);');
    icon.setAttribute('height', '2em');
    icon.setAttribute('width', '2em');
    // icon.setAttribute('width', (i.width / iconHeight) + 'em');
    icon.setAttribute('viewBox', [0, 0, i.width, iconHeight].join(' '));

    path.setAttribute('d', i.path);
    path.setAttribute('transform', 'matrix(1 0 0 -1 0 ' + i.ascent + ')');
    icon.appendChild(path);

    return icon;
};
sheet = document.styleSheets[1]
const svgString = i => createIcon(i).outerHTML.replace(/\"/g, '\''
  ).replace(/<svg /, `<svg xmlns='${svgNS}' `)
const iconRule = (selector, icon) => `${selector} {
  background: no-repeat center center
  url("data:image/svg+xml;utf8,${svgString(icon)}");}`
sheet.insertRule(iconRule('#autoscale', Plotly.Icons.autoscale), 0)
sheet.insertRule(iconRule('#resetzoom', Plotly.Icons.home), 0)

function currentlySelected(){
  let elements = Array.from(document.getElementsByClassName('selected'))
  let seriesClass = elements.filter(e => !classes(e).includes('all-series'))
    .reduce((_, e) => getSeries(classes(e)), undefined)
    // excludes the special case of 'all-series'

  return {seriesClass, elements, series:
    seriesClass ? series.find(s => s.seriesClass === seriesClass) : allSeries}
}

// Series selection
function selectSeries(s){
  if (s && s.id) { // s is #series element
    $('series').className = `ct-label ${s.id}`
    updateParam('outliers', s.id === 'clean' ? 'clean' : null)

    plotVerticalHistogram().then(plotHistogram).then(plotLags)
      .then(wait).then(plotRuntimes).then(wait).then(plotScatterplot)
      .then(function(){
        highlightTraces(currentlySelected().seriesClass)
      })
  } else { // s is seriesClass
    let selected = currentlySelected()
    selected.elements.forEach(deselect)
    // console.log(`select '${s}' and deselect '${selected.seriesClass}'`)

    Array.from(document.getElementsByClassName(s ? s : 'all-series'))
      .forEach(select)
    updateParam('s', s ? s.substring(seriesClassPrefix.length) : null)

    plotVerticalHistogram().then(plotHistogram).then(plotLags)
    .then(highlightTraces(s, selected.seriesClass))
    .then(wait).then(plotRuntimes)
  }
}

function highlightTraces(s, oldSeries){ // param type: seriesClass
  let opacity = Array(series.length).fill(
    (!s) ? 0.5 : oldSeries ? undefined : 0.1)
  if (oldSeries) {
    opacity[seriesIndex(oldSeries)] = (!s) ? 0.5 : 0.1
    Plotly.deleteTraces(chart, 0) // remove mean area
  }
  if (s) { opacity[seriesIndex(s)] = 0.8 }

  Plotly.restyle(chart, {opacity: opacity})
  if (s) {
    Plotly.addTraces(chart, traceMeanArea(series[seriesIndex(s)]), 0)
  }
}

document.onkeydown = selectSeriesWithKeyboard;

function selectSeriesWithKeyboard(e) {
    e = e || window.event;
    var i = seriesIndex(currentlySelected().seriesClass)
    switch (e.keyCode) {
      case 27 /* Esc   */: selectSeries(); return
      case 37 /* Left  */:
        let raw = $('raw')
        raw.checked = true; selectSeries(raw); return
      case 38 /* Up    */: i++; break
      case 39 /* Right */:
        let clean = $('clean')
        clean.checked = true; selectSeries(clean); return
      case 40 /* Down  */: i--; break
      default: return
    }
    i = i % series.length
    if  (i < 0) {i = series.length - 1}
    selectSeries(series[i].seriesClass)
}

function cleanRuntimes(s){
  if (s === allSeries) {
    return series.reduce(
      (a, s) => cleanRuntimes(s).concat(a), []).sort(ascending)
  } else {
    return s.runtimes.slice(0, bisect(s.runtimes, s.cutoff))
  }
}

const columns = [ // [tooltip (title), th label]
  ['Runtimes', ''], ['Series', ''], ['Legend', ''], ['Number of Samples', 'n'],
  ['Minimum', 'Min'], ['Maximum', 'Max'],
  ['Range', 'R'], ['Percent Relative Range', '%'],
  ['1st Quartile', 'Q1'], ['3rd Quartile', 'Q3'],
  ['Interquartile Range', 'IQR'], ['Percent Relative Interquartile Range', '%'],
  ['Median', 'Med'], ['Mean', 'x̅'],
  ['Strandard Deviation', 's'], ['Coeficient of Variation', 'CV'],
  // ['Top Inner Fence (Q3 + 1.5*IQR)', 'TIF'],
  ['Involuntary Context Switches', 'ICS'],
  ['Voluntary Context Switches', 'VCS'],
]

function toPairs(acc, v, i, a) {
  if (i % 2 === 0) acc.push(a.slice(i, i + 2));
  return acc;
}

function element(type, attributes=null, content=null) {
  let e = document.createElement(type)
  for (const attr in attributes) { e.setAttribute(attr, attributes[attr])}
  if (content) {
    if (typeof content === 'number' || typeof content === 'string') {
      e.innerHTML = content
    } else if (typeof content === 'object') {
      if (content instanceof Array) {
        content.filter(c => c ? c : false).forEach(c => {
          if (c instanceof Node) {
              e.appendChild(c)
          } else {
            console.log(`${e}'s content aren't Nodes: ${typeof c} ${c}`);
          }
        })
      }
      else { e.appendChild(content) }
    }
  }
  return e
}

const legendSVG = "<svg width='10' height='6' class='ct-chart-line'>" +
  "<g class='ct-series'><path class='ct-line' d='M0,3h10' />" +
  "<path class='ct-point' d='M5,3h.001'/></g></svg>"

function populateStatsTable() {
  // Columns are joined to pairs and layed out as nested divs with flex, to
  // allow for two row formatting on narrow mobile displays

  div = ([title, label]) => element('div', {title: title}, label)
  divPair = (pair) => element('div', {class: 'pair'},
    pair.map(([title, label]) => element('div', {title: title}, label)))
  wrapInDivs = columnPair => columnPair.map((value, i) =>
    i === 0 ? div(value) : value !== undefined ? divPair(value) : null)

  let titlesHeader = $('titles')
  // columns.forEach(t => titlesHeader.appendChild(th(t)))
  zippedSingleAndDouble = zip([columns, columns.reduce(toPairs, [])])
  const dedupe = ([[a, b], c]) => [[a, b], c === undefined ? c :
    c.filter(([d, e]) => a !== d || b !== e)]
  zippedSingleAndDouble.map(dedupe).map(wrapInDivs).forEach(
    divs => titlesHeader.appendChild(element('th', {}, divs)))

  tr = (seriesClass, typeClass, children) =>
    element('tr', {class: `${seriesClass} ${typeClass}`}, children)

  stats1 = s => [s.n, s.min, s.max, s.range, s.spread]
  stats2 = s => [s.q1, s.q3, s.iqr, s.iqrs,
    s.median, s.mean, s.sd, s.cv, /*s.tif*/]

  values = (s, raw) => {
    sts = raw ? s.rawStats : s.cleanStats
    let line = element('div', {class: "ct-chart ct-square sparkline"})
    line.removeAttribute('id')
    let ss = raw ? s : {
      runtimes: cleanRuntimes(s), name: s.name, seriesClass: s.seriesClass }
    // Store captured closures to plot sparklines later:
    // wait until the line div is inserted into the table,
    // can't plot to element not attached to the document
    sparklines.push(_ => plotSparkline(line, ss))
    return [line, nameOf(s), legendSVG, ...stats1(sts), ...stats2(sts),
      (s.involuntary_cs ? s.involuntary_cs : '—'),
      (s.voluntary_cs ? s.voluntary_cs : '—')]
  }

  let titles = columns.map(([title, label]) => title)
  let rows = []

  const wrapInTd = c => element('td', {}, c)

  const generateSeriesStatRows = s => {
    vals = zip([titles, values(s, false)])
    zippedVals = zip([vals, vals.reduce(toPairs, [])])
    rows.push(tr(s['seriesClass'], 'clean',
      zippedVals.map(dedupe).map(wrapInDivs).map(wrapInTd)))
    vals = zip([titles, values(s, true)])
    zippedVals = zip([vals, vals.reduce(toPairs, [])])
    rows.push(tr(s['seriesClass'], 'raw',
      zippedVals.map(dedupe).map(wrapInDivs).map(wrapInTd)))
  }

  series.forEach(generateSeriesStatRows)
  generateSeriesStatRows(allSeries)

  let statsTable = $('stats')
  rows.forEach(tr => tr.onclick = ev => selectSeries(findSeries(ev.target)))
  rows.reverse().forEach(tr => statsTable.appendChild(tr))

  var s = getParam('s', null) // selected series
  s = s ? (seriesClassPrefix + s) : 'all-series'
  Array.from(document.getElementsByClassName(s)).forEach(select)
}

function computeSetupOverhead() {
  // Compute setup overhead
  // iterations i = 1, j = 2
  // s = (i * j (ti -tj)) / (j - i)
  // setup_overhead = 2 (ti - tj)
  iterations = series.groupBy('num_iters')
  const seriesMin = (series, stat) =>
    series.map(s => s.rawStats[stat]).reduce(min, Number.MAX_SAFE_INTEGER)

  is = Object.keys(iterations).sort(ascending)

  if (is.length > 1) {
    let i = is[0]
    let j = is[1]
    let ti = seriesMin(iterations[i], 'min')
    let tj = seriesMin(iterations[j], 'min')
    // let setup = 2*(ti-tj)
    let setup = (i * j * (ti -tj)) / (j - i)
    let ratio = setup/ti
    if (ratio > 0.05 || allSeries.cleanStats.iqr < setup) {
      let note = $('note')
      note.innerHTML += ` Setup overhead: ${setup}µs (${round(ratio*100, 1)}%) `
    }
    console.log([ti, tj, setup, `${round(setup/ti*100, 2)}%`, allSeries.cleanStats.iqr]);
  }

  // let ti = seriesAverage(iterations[1], 'q1')
  // let tj = seriesAverage(iterations[2], 'q1')
  // console.log([ti, tj, 2*(ti-tj)]);
  // let tk = seriesAverageMinimum(iterations[4])
  // console.log([tj, tk, 8*(tj-tk)/2]);
}

// Traces

function traceRuntime(s, opacity=0.5) {
  let runtimes = seriesIsRaw() ? s.runtimes : cleanRuntimes(s)
  return {
    y: runtimes.slice(),
    name: nameOf(s), mode: 'markers',
    type: 'scatter',
    connectgaps: true, opacity: opacity,
    cliponaxis: false,
    marker: { color: colorForSeries(s), size: 1},
  }
}

function traceScatterPlot(s) {
  let isRaw = seriesIsRaw()
  // TODO subtract setup overhead here during filtering
  let filtered = s => s.data.map(
    runtime => ((isRaw || runtime <= s.cutoff) ? runtime : null ))
  return {
    x: s.data.reduce((a, x, i) => [...a, x * s.num_iters + (a[i-1] || 0)], []),
    y: filtered(s),
    name: nameOf(s),
    type: 'scatter',
    // type: 'scattergl',
    mode: 'lines+markers',
    connectgaps: true, opacity: 0.5, cliponaxis: false,
    marker: { color: colorForSeries(s), size: 5,},
    line : { color: rbgaForSeries(s), width: strokeWidth(log2N(s.data.length))}
  }
}

function traceMeanArea(s) {
  let t = traceScatterPlot(s)
  t.fill = 'toself'; t.mode = 'lines'; t.line.width = 0
  t.fillcolor = fillColorForSeries(s)
  let m = seriesIsRaw() ? s.rawStats.mean : s.cleanStats.mean
  var i = firstNonNull(t.y)
  t.x.splice(i, 0, t.x[i]); t.y.splice(i, 0, m)
  i = lastNonNull(t.y)
  t.x.splice(i + 1, 0, t.x[i]); t.y.splice(i + 1, 0, m)
  return t
}

const defaultAxis = _ => { return {
  tickfont: labelFont, zeroline: false, hoverformat: '.0f',
}}

function axisFormat() {
  return {
    yaxis: { tickfont: labelFont, zeroline: false, hoverformat: '.0f',},
    xaxis: { tickfont: labelFont, zeroline: false, hoverformat: '.0f',},
    showlegend: false, hoverlabel: {font: systemFont}, hovermode: 'closest',
    margin: { l: 35, r: 3, b: 25, t: 5, pad: 2},
  }}

function layoutAxis() {
  let f = axisFormat()
  f.yaxis.zeroline = true
  f.yaxis.range = defaultRange('y')
  f.xaxis.range = defaultRange('x')
  f.margin.l = 2 + (' '+allSeries.cleanStats.max).length * 7 // label length
  return f
}

// plotly_click handler
const selectClickedSeries = click => selectSeries(
  series.find(s => s.name.endsWith(click.points[0].data.name)).seriesClass)

// Workaround to make responsive design work inside iframe in iOS.
// ...without this the iframe kept growing when changing dimension
/// (screen rotation)
const fixDimensions = (plot) => () => fixRelativeDimensions(plot)

function fixRelativeDimensions(e) {
  Plotly.d3.select(e).select('.plot-container').style('height', '100%')
  let plot = Plotly.d3.select(e).select('.svg-container')
  plot.style('height', '100%').style('width', null)
  plot.selectAll('.main-svg').attr('height', '100%').attr('width', '100%')
}

/// Window resizing
windowWidth = window.innerWidth
function resizeMainCharts() {
    if (windowWidth === window.innerWidth) return
    windowWidth = window.innerWidth
    let mainCharts = ['boxplot', 'vertical-histogram', 'chart']
    mainCharts.forEach(c =>
      Plotly.Plots.resize($(c)))
}
// window.onresize = resizeMainCharts

(function() {
  window.addEventListener("resize", resizeThrottler, false);
  var resizeTimeout;
  function resizeThrottler() {
    // ignore resize events as long as an handler execution is in the queue
    if ( !resizeTimeout ) {
      resizeTimeout = setTimeout(function() {
        resizeTimeout = null;
        resizeMainCharts();
     }, 1000) // at most once per second
    }
  }
}());

function resetZoom() {
  let l = layoutAxis()
  l.yaxis.range = allSeries.homeRange.y.slice()
  l.xaxis.range = allSeries.homeRange.x.slice()
  Plotly.relayout(chart, l, true)
}

function zoomAutoscale() {
  Plotly.relayout(chart, {
    'xaxis.range': allSeries.homeRange.x.slice(),
    'yaxis.autorange': true
  }, true)
}

function defaultRange(axis) {
  let r = getParam('r' + axis, null)
  return r ? r.split(' ').map(parseFloat) : allSeries.homeRange[axis].slice()
}

function updateYRange(plot, range) {
  let l = plot.layout
  if (!isEqual(l.yaxis.range, range)) {
    l.yaxis.range = range
    Plotly.relayout(plot, l)
  }
}

function synchronizeZoom() {
  let rx = chart.layout.xaxis.range.map(roundRange)
  updateParam('rx',
    isEqual(rx, allSeries.homeRange.x) ? null : rx[0] + ' ' + rx[1])
  let ry = chart.layout.yaxis.range.map(roundRange)
  updateParam('ry',
    isEqual(ry, allSeries.homeRange.y) ? null : ry[0] + ' ' + ry[1])

  let plots = ['boxplot', 'vertical-histogram']
  plots.forEach(p => updateYRange($(p), ry))
}

function selectedSeries() {
  // FIXME precompute clean runtimes only once and switch the
  // .runtimes pointer to appropriate array in the currentlySelected()
  // This should help eliminate seriesIsRaw, too?
  let selected = currentlySelected().series
  return {
    name: selected.name,// ? selected.name : ' All Series',
    seriesClass: selected.seriesClass,
    runtimes: seriesIsRaw() ? selected.runtimes : cleanRuntimes(selected),
    cutoff: selected.cutoff,
  }
}

function runningMeanVariance([k, M_, S_], x) {
  k = k + 1
  M = M_ + (x - M_) / k
  S = S_ + (x - M_) * (x - M)
  return [k, M, S]
}

function quartileIndexes(n) {
  Q2 = Math.floor(n / 2); Q1 = Math.floor(n / 4); Q3 = Q2 + Q1
  return [Q1, Q2, Q3]
}

function computeStats(a) { // assumes `a` is sorted ascending
  let [n, M, S] = a.reduce(runningMeanVariance, [0, 0, 0])
  let [Q1, Q2, Q3] = quartileIndexes(n)
  let [min, q1, median, q3, max] = [a[0], a[Q1], a[Q2], a[Q3], a[n - 1]]
  let [mean, sd] = [Math.round(M), Math.round(Math.sqrt(S/(n-1)))]
  let [range, iqr] = [max - min, q3 - q1]
  const pom = (r) => (M) ? round((r / M * 100)) + '%' : '-' // percent of mean
  let [cv, spread, iqrs] = [pom(sd), pom(range), pom(iqr)]
  return {
    min, q1, median, q3, max, n, mean, sd, cv, range, spread,
    iqr,  iqrs, tif: round(q3 + 1.5 * iqr),
    sum: a.reduce(sum),
  }
}

// Sparkline layout
const padedRangeForSparkline = ([s, e]) => {
  p = (e - s)/32 // sparkline is 1em (16px) square; inset edges by half a point
  return [s-p, e+p]
}
const xRangeSparkline = s => padedRangeForSparkline([0, s.runtimes.length-1])
const yRangeSparkline = s =>
  padedRangeForSparkline([s.runtimes[0], s.runtimes[s.runtimes.length - 1]])
const sparklineAxis = {showticklabels: false, showgrid: false, zeroline: false}

const sparklineLayoutFor = s => {
  return {
    yaxis: join(sparklineAxis, {range:  yRangeSparkline(s)}),
    xaxis: join(sparklineAxis, {range:  xRangeSparkline(s)}),
    showlegend: false,
    margin: { l: 0, r: 0, b: 0, t: 0, pad: 0},
    paper_bgcolor: 'rgba(0,0,0,0)',
    plot_bgcolor: 'rgba(0,0,0,0)',
  }
}

const staticPlot =  {staticPlot: true, displayModeBar: false,}

const sum = (a, c) => a + c
const suma = ([a, c]) => a + c
// const outliers = s => s.data.filter(x => x > s.rawStats.tif)
// const propers = s => s.data.filter(x => x <= s.rawStats.tif)
// const errors = s => outliers(s).map(x => (x - s.rawStats.median) * s.num_iters)
// cumulativeError = series.map(errors).map(es => es.reduce(sum))
// totalRuntime = series.map(s => s.data.map(x => x * s.num_iters).reduce(sum))
// errorRatio = zip([totalRuntime, cumulativeError]).map(([rt, e]) => e/rt)
// outs = series.map(outliers)
// pros = series.map(propers)
// outsSum = outs.map(a => a.reduce(sum))
// prosSum = pros.map(a => a.reduce(sum))
// allSum = zip([outsSum, prosSum]).map(suma)
// errorPercentage = zip([outsSum, allSum]).map(([o,a])=> o/a)

const nameOf = s => s.name.split(' ')[1] // throw away common prefix

const boxplot5numSummary = s =>
  [s.rawStats.min, s.rawStats.q1, s.rawStats.median,
    s.rawStats.median, s.rawStats.q3, s.cleanStats.max]

function traceBoxPlot(s) {
  // console.log(s.name, boxplot5num(s))
  return {
    name: nameOf(s),
    type: 'box',
    opacity: 0.5,
    y: boxplot5numSummary(s),
    boxpoints: false,
    marker: { color: colorForSeries(s) },
    line : { width: 1.4}
  }}
function traceVerticalHistogram(s) {
  return {
    name: nameOf(s),
    type: 'histogram',
    hoverinfo:'x+y',
    ybins: {
      start: allSeries.cleanStats.min-1,
      end: allSeries.cleanStats.max+1,
      size: Math.ceil(allSeries.cleanStats.max/1000),
    },
    opacity: 0.6,
    // y: cleanRuntimes(s),
    y: s.runtimes,
    marker: { color: colorForSeries(s) }
  }}

const padX = {
  2: 0.005, 4: 0.01, 8: 0.025, 16: 0.05, 32: 0.1, 64: 0.25, 128: 0.5, 256: 1,
  512: 2.5, 1024: 5, 2048: 7.5, 4096: 15, 8192: 20, 16384: 50, 32768: 100
}

const lag = (a, l) => a.slice(l).concat(a.slice(0, l))

function traceLag(s, l) {
  let isRaw = seriesIsRaw()
  let filtered = s.data.filter(runtime => (isRaw || runtime <= s.cutoff))
  return [{
    x: filtered,
    y: lag(filtered, l),
    type: 'pointcloud',
    hoverinfo: 'x+y',
    opacity: 0.6,
    marker: { color: colorForSeries(s) },
  }]
}

function plotSparkline(line, ss) {
  if (isHidden($('stats'))) return
  return Plotly.newPlot(
    line, [traceRuntime(ss, 0.7)], sparklineLayoutFor(ss), staticPlot)
}

function plotLags() {
  let lag = $('lag');  if (isHidden(lag)) return
  return Plotly.newPlot(
    lag, traceLag(currentlySelected().series, 1), axisFormat(), noModeBar)
}

function plotRuntimes() {
  let rtPlot = $('runtimes'); if (isHidden(rtPlot)) return
  let series = selectedSeries()
  let {runtimes, seriesClass} = series
  let s = computeStats(runtimes)
  tifIndex = bisect(runtimes, series.cutoff)
  tifPercentile = tifIndex / s.n
  let raw = (series.cutoff < s.max)
  fiveNumberSummary = [s.min, s.q1, s.median, s.q3, s.max]
  rt = traceRuntime(series)
  rt.marker.size = 5.0
  rt.cliponaxis = false

  // Mean area plot
  let t = traceRuntime(series)
  t.fill = 'toself'; t.mode = 'lines'; t.line = {width: 0}
  t.fillcolor = fillColorForSeries(series)
  t.x = [...Array(s.n).keys()]
  var i = 0
  t.x.splice(i, 0, t.x[i]); t.y.splice(i, 0, s.mean)
  i = s.n
  t.x.splice(i + 1, 0, t.x[i]); t.y.splice(i + 1, 0, s.mean)

  let layout = axisFormat()
  layout.yaxis.tickvals = raw ? [s.min, s.tif, s.max] : fiveNumberSummary
  layout.yaxis.ticktext = raw ? [s.min, '', s.max] : undefined

  var p = (s.max - s.min) * 0.01
  layout.yaxis.range = [s.min - p, s.max + p]
  layout.xaxis.tickvals = raw ? [0, tifIndex - .5] : [0, ...quartileIndexes(s.n), (s.n - 1)]
  // FIXME labels for n = 2, 3, 4 (when 5 no. summary doesn't fit)
  layout.xaxis.ticktext = raw ? [0, tifIndex] : ['Min', 'Q1', 'Med', 'Q3', 'Max']

  let p2 = Math.pow(2, Math.ceil(Math.log2(s.n)))
  p = padX[p2] * 2.5
  layout.xaxis.range = [0 - p, s.n - 1 + p]
  layout.margin.r = 15
  layout.margin.t = raw ? 10 : 5
  layout.margin.l = 2 + (''+s.max).length * 7 // label length
  layout.annotations = raw ? [ {
      xref: 'x', yref: 'y', x: tifIndex -.5, y: s.max,
      xanchor: 'right', yanchor: 'bottom',
      // xref: 'paper', yref: 'paper', x: 'middle', y: 'top',
      // xanchor: 'middle', yanchor: 'top',
      text: `Top Inner Fence at ${Math.round(tifPercentile*100)}%`,
      font: labelFont,
      showarrow: false
    },
    {
        xref: 'x', yref: 'y', x: s.n -1, y: (s.min + s.max)/2,
        xanchor: 'left', yanchor: 'middle',
        text: `${s.n-tifIndex} outlier${s.n-tifIndex > 1 ? 's' : ''}`,
        textangle: -90,
        font: labelFont,
        showarrow: false
      },
    {
        xref: 'x', yref: 'y', x: tifIndex -.5, y: s.tif,
        xanchor: 'right', yanchor: 'bottom',
        text: `TIF: ${s.tif}`,
        font: labelFont,
        showarrow: false
      },
    ] : []
// console.log('runtimes starting plot')
  return Plotly.newPlot(rtPlot, [rt, t], layout, noModeBar)
}

function plotVerticalHistogram() {
  let vh = $('vertical-histogram'); if (isHidden(vh)) return

  let s = selectedSeries()
  let l = layoutSansAxis()
  l.annotations = [{
      xref: 'paper', yref: 'paper', x: 0, y: 0,
      xanchor: 'middle', yanchor: 'top',
      text: `⩥ ${Math.ceil(allSeries.cleanStats.max/1000)}µs`,
      font: labelFont,
      showarrow: false
    }]

  let p = Plotly.newPlot(vh, [traceVerticalHistogram(s)], l, noModeBar)
  vh.on('plotly_afterplot', fixDimensions(vh))
  return p
}

function plotHistogram() {
  let histogram = $('histogram'); if (isHidden(histogram)) return
  let s = selectedSeries()
  let {runtimes, seriesClass} = s
  // let {min, max, mean, sd, runtimes, seriesClass} = s
  let {min, max, mean, sd} = computeStats(runtimes)

  bs = (sd > 1) ? sd : 1 // bucket size
  lo = mean - (Math.ceil((mean-min)/bs)*bs)
  hi = mean + (Math.ceil((max-mean)/bs)*bs)
  steps = Math.min(Math.ceil((hi - lo)/bs), 10)

  start = (lo - mean) / bs // bs ~= sd; how many SDs from mean is start?
  sdMultiples = x => start + x
  symbols = m => (m === -1) ? '-s' : (m === 0) ? 'x̅' : (m === 1) ? 's' : m + 's'
  const labels = i => symbols(sdMultiples(i))

  splits = i => lo + (i * bs)
  intervals = x=>[x - 1, x + bs - 1]
  indexes = ([l, h]) => [bisect(runtimes, l), bisect(runtimes, h)]
  frequencyCount = ([l, h]) => h-l
  const computeHistogram = i => frequencyCount(indexes(intervals(splits(i))))
  hist = [...Array(steps).keys()].map(computeHistogram)
  hist.push(0)
  yTicks = hist.slice().sort(descending).slice(0,2)
  xTicks = [...Array(steps+1).keys()].map(splits)

  let layout = axisFormat()
  layout.yaxis.tickvals = yTicks
  layout.xaxis.tickvals = xTicks
  layout.xaxis.ticktext = [...Array(steps+1).keys()].map(labels)
  layout.xaxis.range = [xTicks[0], xTicks[xTicks.length - 1]]
  layout.yaxis.range = [0, yTicks[0] + (yTicks[0] * 0.01)], // align w runtimes
  layout.margin.r = 7
  layout.margin.l = 2 + (''+yTicks[0]).length * 7 // label length

  return Plotly.newPlot(histogram,
  [{
    name: nameOf(s), type: 'histogram', hoverinfo:'x+y',
    x: s.runtimes,
    xbins: { start: lo, end: hi, size: sd, },
    opacity: 0.6, marker: { color: colorForSeries(s) }
  }],
  layout,
  noModeBar)
}

function plotBoxplot () {
  let bp = $('boxplot'); if (isHidden(bp)) return
  let p = Plotly.newPlot(bp,
    series.map(traceBoxPlot).reverse(),
    join(layoutSansAxis(), {hovermode: ''}), noModeBar)
  bp.on('plotly_click', selectClickedSeries)
  bp.on('plotly_afterplot', fixDimensions(bp))
  return p
}


function plotScatterplot() {
  if (isHidden(chart)) return
  let p = Plotly.newPlot(chart,
    series.map(traceScatterPlot), layoutAxis(), noModeBar)
  chart.on('plotly_afterplot', synchronizeZoom)
  chart.on('plotly_afterplot', fixDimensions(chart))
  chart.on('plotly_click', selectClickedSeries)
  return p
}

function layoutSansAxis() {
  let f = axisFormat()
  f.yaxis.range = defaultRange('y')
  f.yaxis.zeroline = true
  f.yaxis.showgrid = true
  f.yaxis.showticklabels = false
  f.xaxis.showgrid = false
  f.xaxis.showticklabels = false
  f.margin.l = 5
  return f
}
const noModeBar = {displayModeBar: false,}

let chart = $('chart')
let histogram = $('histogram')

let sparklines = []
var series = []
var runtimes = []
let allSeries

Array.prototype.groupBy = function(prop) {
  return this.reduce(function(groups, item) {
    var val = item[prop];
    groups[val] = groups[val] || [];
    groups[val].push(item);
    return groups;
  }, {});
}

function getParam(name, defaultValue='') {
  let value = (new URLSearchParams(location.search)).get(name)
  return value ? value : defaultValue
}

function updateParam(name, value) {
  let params = new URLSearchParams(location.search)
  if (value) { params.set(name, value) }
  else { params.delete(name) }
  window.history.replaceState({}, '', `${location.pathname}?${params}`)
}

// Hide parts specified in URL parameters
getParam('hide').split(' ').filter(s => s.length > 0).forEach(c =>
  Plotly.d3.select(`.${c}`).classed('hide', true)
)

let outliers = getParam('outliers', 'raw')
setClass($('series'), outliers)
$(outliers).checked = true

var logFile = getParam('f', 'f.json')
fetch(logFile).then(function(response) {
  return response.json();
}).then(function(data) {
  allSeries = data
  $('title').innerHTML = data.name;
  document.title = data.name;

  const _2k = 2048

  let maxSeriesLength = data.series.map(s => s.data.length).reduce(max)
  if (maxSeriesLength > _2k) {
    // $('note').innerHTML = 'Series longer than 2k were trimmed.'
    $('note').innerHTML = 'Trimmed series w/ n > 2k.'
  }
  data.series.forEach(s => {
    let l = s.data.length
    if (s.data.length > _2k){
      s.data = s.data.slice(0, _2k)
      // console.log(`trimmed series ${s.name} from ${l} to ${s.data.length}`)
    }
  })
  series = data.series.sort(descendingByIterationsAndName)
  // Prepare runtimes for histogram
  allSeries.runtimes = []
  allSeries.data = []
  allSeries.involuntary_cs = 0
  allSeries.involuntary_cs = 0
  series.forEach(s => {
    allSeries.runtimes = s.data.concat(allSeries.runtimes)
    allSeries.data = s.data.concat(allSeries.data)
    allSeries.involuntary_cs += s.involuntary_cs
    allSeries.voluntary_cs += s.voluntary_cs
    s.runtimes = s.data.slice().sort(ascending)
    s.rawStats = computeStats(s.runtimes)
    s.cutoff = s.rawStats.tif
    s.cleanStats = computeStats(cleanRuntimes(s)) // must be after cutoff is set
    s.seriesClass = seriesClassPrefix + s.name.split(' ')[1]
  })
  allSeries.runtimes.sort(ascending)
  allSeries.rawStats = computeStats(allSeries.runtimes)
  allSeries.cleanStats = computeStats(cleanRuntimes(allSeries)) // is fine here
  allSeries.cutoff = allSeries.cleanStats.max
  allSeries.seriesClass = 'all-series'
  allSeries.name += ' all'
  let p = round(allSeries.cleanStats.range * 0.01, 1)
  allSeries.homeRange = {
    y: [allSeries.cleanStats.min - p,
        allSeries.cleanStats.max + p].map(roundRange),
    x: [0, Math.max(...series.map(elapsedTime))]
  }

  generateSeriesCSS()
  populateStatsTable()
  computeSetupOverhead()
})
.then(generateNavigationForm)
.then(plotVerticalHistogram)
.then(plotBoxplot)
.then(plotHistogram)
.then(plotLags)
.then(function(){
  // These charts take longer to plot, delay them a bit, so that
  // faster charts above are displayed as soon as possible
  wait(1).then(plotRuntimes)
  wait(10).then(plotScatterplot).then(function(){
    highlightTraces(currentlySelected().seriesClass)
  })
  sparklines.forEach(plot => wait(1000).then(plot))
})

const isHidden = e => e.offsetParent === null

function generateNavigationForm(){ // Navigation form
  let benchmark = $('benchmark')
  if (isHidden(benchmark)) { return }

  let logFileComponents = logFile.split(' ')
  let fileSuffix = logFileComponents.length ? logFileComponents[1] : ''

  var benchmarks
  fetch('benchmarks.json').then(function(response) {
    return response.json();
  }).then(function(data) {
    benchmarks = data
    const option = (t) => {
      let o = document.createElement('option')
      o.value = t + ' ' + fileSuffix
      o.text = t
      return o
    }
    benchmarks.forEach(t => benchmark.appendChild(option(t)))
    let benchmarkName = allSeries.name.split(' ')[0]
    benchmark.selectedIndex = benchmarks.findIndex(t => t === benchmarkName)
  })
}

/* TODO ?
 - add micro histograms to table
 - Excludes Outliers: iteratively (while TIF < MAX), do also Bottom Inner Fence
*/
</script>
  </body>
</html>
