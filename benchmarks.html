<!DOCTYPE html>
<!--
TODO
 links to chart.html?f=XXX
 sorting
 boxplot
 FIXME sum of all samples is strange for n = 4096
 -->
<html>
  <head>
    <title>Benchmarks</title>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- <script type="text/javascript" src="http://d3js.org/d3.v3.min.js"></script> -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
      body {font-family: system-ui, -apple-system;}
      h1 {font-size: 1.5rem}
      h2 {font-size: 1.1rem; margin-top: 0;}
      a {text-decoration: none;}
      td a {display: block; width: 100%}
      table {font-variant-numeric: tabular-nums;
        border-collapse:collapse; border-spacing:0;
        text-align: right; font-size: .6rem;  color: rgba(0, 0, 0, .4);
      }
      td {padding: 0.1em .333em; vertical-align: bottom;}
      th:first-child {text-align: left;}
      td:first-child {max-width: 24em; text-align: left;}
      .spacer {max-width: 24em; margin: -1.2em 0 0 0; color: orange;
        visibility: hidden;
        white-space: pre-wrap; word-wrap: break-word;}
      tbody tr:hover {background-color: Highlight; }
      tr {border-bottom: 1px solid rgba(0,0,0, .1)}
      .caption {display: flex; flex-flow: row wrap; color: black; }
      .caption > * {margin: auto 0; flex: 0 0 auto;}
      .caption form {font-size: 0.75rem;
        margin: auto .8em auto 1em;}

      .ascending {
        background: linear-gradient(to top, Highlight 0%, white 100%)}
      .descending {
        background: linear-gradient(to bottom, Highlight 0%, white 100%)}

    </style>
    <meta name="viewport" content="initial-scale=1.0">
    <script>
      const $ = id => document.getElementById(id)
      d3 = Plotly.d3
    </script>
  </head>
  <body>

<script>

Array.prototype.groupBy = function(prop) {
  return this.reduce(function(groups, item) {
    var val = item[prop];
    groups[val] = groups[val] || [];
    groups[val].push(item);
    return groups;
  }, {});
}

function round(x, precision = 0) {
  let factor = Math.pow(10, precision);
  return Math.round(x * factor) / factor;
}

function getParam(name, defaultValue='') {
  let value = (new URLSearchParams(location.search)).get(name)
  return value ? value : defaultValue
}

function updateParam(name, value) {
  let params = new URLSearchParams(location.search)
  if (value) { params.set(name, value) }
  else { params.delete(name) }
  window.history.replaceState({}, '', `${location.pathname}?${params}`)
}

const zip = rows=>rows[0].map((_,c)=>rows.map(row=>row[c]))
const enumerate = a => zip([[...a.keys()], a])

const seriesColumns = [ // [tooltip (title), th label]
  ['Runtimes', ''], ['Series', ''], ['Legend', ''], ['Number of Samples', 'n'],
  ['Minimum', 'Min'], ['Maximum', 'Max'],
  ['Range', 'R'], ['Percent Relative Range', 'R%'],
  ['1st Quartile', 'Q1'], ['3rd Quartile', 'Q3'],
  ['Interquartile Range', 'IQR'], ['Percent Relative Interquartile Range', '%'],
  ['Median', 'Med'], ['Mean', 'xÌ…'],
  ['Strandard Deviation', 's'], ['Coeficient of Variation', 'CV'],
  ['Involuntary Context Switches', 'ICS'],
  ['Voluntary Context Switches', 'VCS'],
]

const allColumns = [
  ['Benchmark', 'Benchmark'], ['Setup Overhead', 'SO'],
  ['Number of Samples per Series','n'], ['Total Number of Samples','âˆ‘n'],
  ...seriesColumns.slice(4)]

const columns = [
  ['Benchmark', 'Benchmark'], ['Number of Samples per Series','n'],
  ['Accumulated Error: xÌ… - Min', 'ME'],
  ['Percent Relative Accumulated Error', 'ME%'],
  ['Minimum', 'Min'],
  ['Best Mean', 'xÌ…'], ['Clean Median', 'Med'],
  ['Accumulated Error: xÌ… - Med', 'E'],
  ['Percent Relative Accumulated Error', 'E%'],
  ['Interquartile Range', 'IQR'],
  ['Percent Relative Interquartile Range', '%'],
  ['Involuntary Context Switches', 'ICS'],
  ['Setup Overhead', 'SO']
]

const seriesKeys = ['name', 'count', 'min', 'max', 'range', 'rrange',
  'q1', 'q3', 'iqr', 'riqr', 'median', 'mean', 'sd', 'cv',
  'ics', 'vcs', 'max_rss', 'outliers']
  .reduce((m, k, v) => {m[k] = v; return m}, {})

const Stats = (s) => new Proxy(s, {
  get: function(obj, prop) {
    return obj[prop] || s[seriesKeys[prop]]
  }})

const emptyStats = (() => { // ðŸ–• TypeFlood
  let e = Array(seriesKeys.length); e.fill(''); e[0] = 'all'; return e
})()

const allSeries = s => s.name === 'all'
const not = f => (p) => !f(p)

var bs

let variant = getParam('variant', 'ten')

var statsFile = `benchmarks ${variant}.json`
fetch(statsFile).then(function(response) {
  return response.json();
}).then(function(benchmarks) {
  bs = benchmarks
  benchmarks.forEach(b => {
    raw = b.rawStats.map(Stats)
    clean = b.cleanStats.map(Stats)
    b.all = {
      raw: raw.filter(allSeries)[0] || emptyStats,
      clean: clean.filter(allSeries)[0] || emptyStats,
    }
    b.raw = raw.filter(not(allSeries))
    b.clean = clean.filter(not(allSeries))
    if (b.setup_overhead) {
      b.all.fixed = Stats(b.setup_overhead[2])
    }
  })

  let body = d3.select('body')
  body.append('h1').text(`'${variant}' Series`)

  let buckets = benchmarks.groupBy('num_samples')
  bs = buckets

  body.selectAll('table').data(Object.entries(buckets)).enter()
    .append('table')
    .each(function([num_samples, benchmarks]) {
      let table = d3.select(this)
      table.append('caption').append('div').attr('class', 'caption')
        .append('h2').text(num_samples)
      let thead = table.append('thead')
      let tbody = table.append('tbody')
      let rows = tbody.selectAll('tr').data(benchmarks).enter().append('tr')

      thead.selectAll('th').data(columns).enter()
    		  .append('th')
            .attr('title', ([title, _]) => title)
    		    .text(([_, label]) => label)
            .on('click', sortRowsByColumn(rows))
      thead.select('th:first-child').attr('class', 'ascending')

      rows.selectAll('td').data(cellsForBenchmark).enter()
    	  .append('td')
        .each(function ([[title, label], value], i) {
          let td = d3.select(this)
          td.attr('title', title)
          if (i === 0) { // first cell
            td.append('a')
              .attr('target', 'there')
              .attr('href', `chart.html?f=${value} ${variant}.json`)
              .text(value)
            td.append('div').attr('class', 'spacer').text(value)
          } else {
            td.text(value)
          }
        })
    })
})

const num_iters = s => parseInt(s.name.substring(1, s.name.length - 1))

function cellsForBenchmark(b) {
  let overhead = b.setup_overhead ? b.setup_overhead[0] : 0
  let minMean = Math.min(...b.raw.map(
    s => s.mean - round(overhead / num_iters(s))))
  let all = b.all.fixed || b.all.clean
  let median = all.median
  let values = [
    b.name, b.num_samples,
    (minMean - all.min), round((minMean - all.min) / all.min * 100) + '%',
    all.min, minMean, median, (minMean - median),
    round((minMean - median) / median * 100) + '%',
    all.iqr, all.riqr, all.ics, setupOverhead(b)]

  let c = zip([columns, values])
  c.forEach( // cache values for quick sorting
    ([[title, label], value], i) => {
      b[label] = (i ===0) ? value /* Benchmark */
      : parseInt(value) || 0 })
  return c
}

const v = (benchmark, column) => // value accessor
  benchmark[column[1]]

function sortRowsByColumn(rows) {
  return function(c) {
    const sortingClass = (order) => order ? 'ascending' : 'descending'
    const sortingOrder = (sorted) => sorted.classed('ascending')

    let oldSorted =
      d3.select(this.parentNode).select("th.ascending,th.descending")
    let newSorted = d3.select(this)

    var order = sortingOrder(oldSorted)
    oldSorted.classed(sortingClass(order), false) // remove old

    if (oldSorted[0][0] === newSorted[0][0]) order = !order
    newSorted.classed(sortingClass(order), true) // set new

    if (order) {
      rows.sort((a, b) => v(a, c) > v(b, c))
      // rs.sort((a, b) => d3.ascending(v(a, c), v(b, c)))
    } else {
      rows.sort((a, b) => v(a, c) < v(b, c))
      // rs.sort((a, b) => d3.descending(v(a, c), v(b, c)))
    }
  }
}


const noOverhead = [0, 0]
function setupOverhead(benchmark) {
  iqr = benchmark.all.clean.iqr
  if (!benchmark.setup_overhead) return ''
  let [setup, ratio, _] = benchmark.setup_overhead
  return `${round(ratio*100)}% (${setup}Âµs)`
}
  // } else if (i === 1) { // setup overhead, 2nd cell
  // if (value && value[0] !== 0) {
  //   [setup, ratio] = value
  //   td.text(`${setup}Âµs (${round(ratio*100, 1)}%)`)
  // }

</script>
  </body>
</html>
